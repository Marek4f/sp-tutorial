#### {% title "Jak zostać Uniksowym guru w kwadrans" %}

[unix guru]: http://www.cs.usfca.edu/~parrt/course/601/lectures/unix.util.html "How To Look Like A UNIX Guru"


# Jak zostać Uniksowym guru w kwadrans

<blockquote>
  {%= image_tag "/images/richard_stallman.jpg", :alt => "[Richard Stallman]" %}
  <p>
   Richard M. Stallman, Linus Torvalds,
   and Donald E. Knuth engage in a discussion on whose impact
   on the computerized world was the greatest.<br/>
   Stallman: "God told me I have programmed
   the best editor in the world!"
   Torvalds: "Well, God told *me* that I have programmed
   the best operating system in the world!"
   Knuth: "Wait, wait &#x2013; I never said that."
  </p>
  <p class="author">[from rec.humor.funny]</p>
</blockquote>

UNIX is an extremely popular platform for deploying server software
partly because of its security and stability, but also because it has
a rich set of command line and scripting tools. Programmers use these
tools for manipulating the file system, processing log files, and
generally automating as much as possible.

If you want to be a serious server developer, you will need to have a
certain facility with a number of UNIX tools; about 15. You will start
to see similarities among them, particularly regular expressions, and
soon you will feel very comfortable. Combining the simple commands,
you can build very powerful tools very quickly—much faster than you
could build the equivalent functionality in C or Java, for example.


## Wszystko jest strumieniem

The first thing you need to know is that UNIX is based upon the idea
of a *stream*.  Everything is a *stream*, or appears to be. Device
drivers look like streams, terminals look like streams, processes
communicate via streams, etc…  The input and output of a program are
streams that you can redirect into a device, a file, or another
program.

Here is an example device, the null device, that lets you throw output
away.  For example, you might want to run a program but ignore the
output.

    :::shell-unix-generic
    ls > /dev/null # ignore output of ls

where "`# ignore output of ls`" is a comment.

Most of the commands covered in this lecture process `stdin`
and send results to `stdout`.  In this manner, you can
incrementally process a data stream by hooking the output of one tool
to the input of another via a *pipe*.  For example, the
following piped sequence prints the number of files in the current
directory modified in August.

    :::shell-unix-generic
    ls -l | grep Aug | wc -l

Imagine how long it would take you to write the equivalent C or Java
program.  You can become an extremely productive UNIX programmer if
you learn to combine the simple command-line tools.  Even when
programming on a PC, I use MKS's UNIX shell and command library to
make it look like a UNIX box.  Worth the cash.  


## Uzyskiwanie pomocy

If you need to know about a command, ask for the "man" page.  For
example, to find out about the `ls` command, type

    :::shell-unix-generic
    man ls
    LS(1)       User Commands       LS(1)
    
    NAME
         ls - list directory contents
    
    SYNOPSIS
         ls [OPTION]... [FILE]...
    
    DESCRIPTION
         List information about the FILEs (the current directory 
         by default). Sort entries alphabetically if none 
         of -cftuvSUX nor --sort.
    ...

You will get a summary of the command and any arguments.

If you cannot remember the command's name, try using `apropos`
which finds commands and library routines related to that word.  
For example, to find out how to do checksums, type

    apropos checksum
    cksum(1), sum(1)  - display file checksums and block counts


## Special Directories and files

A shortcut for you home directory, <TT>/home/</TT><em>username</em>, is
<TT>~</TT><em>username</em>.  For example, <TT>~parrt</TT> is my home directory,
<TT>/home/parrt</TT>.

When you are using the shell, there is the notion of <em>current
directory</em>.  The dot '<TT>.</TT>' character is a shorthand for the current
directory and '<TT>..</TT>' is a shorthand for the directory above the
current.  So to access file <TT>test</TT> in the current directory, <TT>./test</TT>

is the same as plain <TT>test</TT>.  If <TT>test</TT> is a directory above, use
<TT>../test</TT>.

<TT>/</TT> is the root directory; there is no drive specification in UNIX.

The <TT>.bash\_profile</TT> file is very important as it is how your shell
session is initialized including your ever-important <TT>CLASSPATH</TT>

environment variable.  Your <TT>bash</TT> shell initialization file is
<TT>~</TT><em>username</em><TT>/.bash_profile</TT> and has set up code like the following:

<div class="code"><PRE>
PATH=$PATH:$HOME/bin
</PRE></div>

Typically, you will go in and set your <TT>CLASSPATH</TT> so that you don't
have to set it all the time.

<div class="code"><PRE>
export CLASSPATH=".:/home/public/cs601/junit.jar"
</PRE></div>

The <TT>export</TT> means that the assignment to <TT>CLASSPATH</TT> is visible to
all child processes (that is, visible to all programs you run from the
shell).

## The basics

### cd

Changing a directory is done with <TT>cd</TT> <em>dir</em> where <em>dir</em> can be "." or
".." to move to current directory (do nothing) or go up a directory.

### ls

Display files in a directory with <TT>ls</TT>.  The <TT>-l</TT> option is used to
display details of the files:

<div class="code"><PRE>
total 9592
-rw-r--r--    1 parrt  staff     5600 Aug 19  2005 C-Java-relationship.html
...
drwxr-xr-x   13 parrt  staff      442 Oct 19  2005 sessions
-rw-r--r--    1 parrt  staff     2488 Oct 19  2005 sessions.html
...
</PRE></div>

"staff" is parrt's group.

If you want to see hidden files (those starting with "."), use "-a".

Combinations are possible: use "ls -la" to see details of all files
including hidden ones.

## displaying files

There are 4 useful ways to display the contents or portions of a file.
The first is the very commonly used command <TT>cat</TT>.  For example, to
display my list of object-oriented keywords used in this course, type:

<div class="code"><PRE>

$ cat /home/public/cs601/oo.keywords.txt
</PRE></div>

If a file is really big, you will probably want to use <TT>more</TT>,
which spits the file out in screen-size chunks.

<div class="code"><PRE>
$ more /var/log/mail.log
</PRE></div>

If you only want to see the first few lines of a file or the last few
lines use <TT>head</TT> and <TT>tail</TT>.

<div class="code"><PRE>
$ head /var/log/mail.log
$ tail /var/log/mail.log
</PRE></div>

You can specify a number as an argument to get a specific number of
lines:

<div class="code"><PRE>
$ head -30 /var/log/mail.log
</PRE></div>

The most useful incantation of <TT>tail</TT> prints the last few lines of a
file and then waits, printing new lines as they are appended to the
file.  This is great for watching a log file:

<div class="code"><PRE>
$ tail -f /var/log/mail.log
</PRE></div>

If you need to know how many characters, words, or lines are in a
file, use <TT>wc</TT>:

<div class="code"><PRE>
$ wc /var/log/mail.log
     164    2916   37896 /var/log/mail.log
</PRE></div>

Where the numbers are, in order, lines, words, then characters.  For
clarity, you can use <TT>wc -l</TT> to print just the number of lines.

### pushd, popd

Instead of <TT>cd</TT> you can use <TT>pushd</TT> to save the current
dir and then automatically <TT>cd</TT> to the specified directory.
For example,

<div class="code"><PRE>
$ pwd
/Users/parrt
$ pushd /tmp
/tmp ~
$ pwd
/tmp
$ popd
~
$ pwd
/Users/parrt
</PRE></div>

### top

To watch a dynamic display of the processes on your box in action, use 
`top` or `htop`.

### ps

To print out (wide display) all processes running on a box, use 

    :::shell-unix-generic
    ps auxww  # double w

### chmod

To change the privileges of a file or directory, use `chmod`.  The
privileges are 3 digit octal words with 3 bits per digit: rwxrwxrwx
where the first digit is for the file owner, the 2nd for the group,
and 3rd for anybody.  644 is a common word value file which means
110100100 or

    rw-r--r--

When you do `ls -l` you will see these bits. 

755 is a common word value for directories: 

    rwxr-xr-x 

where directories need to be executable for `cd` to be able to enter that
dir. 755 is a shorthand for the more readable argument 

    u=rwx,go=rx

u is user, g is group, o is other.

Use `chmod -R` for recursively applying to all the dirs below the
argument as well.


## Searching streams

One of the most useful tools available on UNIX and the one you may use
the most is <TT>grep</TT>.  This tool matches regular expressions
(which includes simple words) and prints matching lines to
<TT>stdout</TT>.

The simplest incantation looks for a particular character sequence in
a set of files.  Here is an example that looks for any reference to
<TT>System</TT> in the java files in the current directory.

<div class="code"><PRE>
grep System *.java
</PRE></div>

You may find the dot '.' regular expression useful.  It matches any
single character but is typically combined with the star, which
matches zero or more of the preceding item.  Be careful to enclose the
expression in single quotes so the command-line expansion doesn't
modify the argument.  The following example, looks for references to
any a forum page in a server log file:

<div class="code"><PRE>
$ grep '/forum/.*' /home/public/cs601/unix/access.log
</PRE></div>

or equivalently:

<div class="code"><PRE>
$ cat /home/public/cs601/unix/access.log | grep '/forum/.*' 
</PRE></div>

The second form is useful when you want to process a collection of
files as a single stream as in:

<div class="code"><PRE>
cat /home/public/cs601/unix/access*.log | grep '/forum/.*'
</PRE></div>

If you need to look for a string at the beginning of a line, use caret '^':

<div class="code"><PRE>
$ grep '^195.77.105.200' /home/public/cs601/unix/access*.log
</PRE></div>

This finds all lines in all access logs that begin with IP address
195.77.105.200.

If you would like to invert the pattern matching to find lines that do
not match a pattern, use <TT>-v</TT>.  Here is an example that finds
references to non image <TT>GET</TT>s in a log file:

<div class="code"><PRE>
$ cat /home/public/cs601/unix/access.log | grep -v '/images'
</PRE></div>

Now imagine that you have an http log file and you would like to
filter out page requests made by nonhuman spiders.  If you have a file
called <TT>spider.IPs</TT>, you can find all nonspider page views via:

<div class="code"><PRE>
$ cat /home/public/cs601/unix/access.log | grep -v -f /tmp/spider.IPs
</PRE></div>

Finally, to ignore the case of the input stream, use <TT>-i</TT>.


## Przekształcanie strumieni tekstu

Morphing a text stream is a fundamental UNIX operation.

### tr

For manipulating whitespace, you will find `tr` very useful.

If you have columns of data separated by spaces and you would like the
columns to collapse so there is a single column of data, tell
<TT>tr</TT> to replace space with newline <TT>tr ' ' '\n'</TT>.
Consider input file <TT>/home/public/cs601/unix/names</TT>:

    :::shell-unix-generic
    jim scott mike
    bill randy tom

To get all those names in a column, use

<div class="code"><PRE>
$ cat /home/public/cs601/unix/names | tr ' ' '\n'
</PRE></div>

If you would like to collapse all sequences of spaces into one single
space, use <TT>tr -s ' '</TT>.

To convert a PC file to UNIX, you have to get rid of the '\r'
characters.  Use <TT>tr -d '\r'</TT>.

### sed

If dropping or translating single characters is not enough, you can
use <TT>sed</TT> (stream editor) to replace or delete text chunks matched by
regular expressions.  For example, to delete all references to word
<TT>scott</TT> in the names file from above, use

<div class="code"><PRE>
$ cat /home/public/cs601/unix/names | sed 's/scott//'
</PRE></div>

which substitutes <TT>scott</TT> for nothing.  If there are multiple
references to <TT>scott</TT> on a single line, use the <TT>g</TT>
suffix to indicate "global" on that line otherwise only the first
occurrence will be removed:

<div class="code"><PRE>
$ ... | sed 's/scott//g'
</PRE></div>

If you would like to replace references to <TT>view.jsp</TT> with
<TT>index.jsp</TT>, use

<div class="code"><PRE>
$ ... | sed 's/view.jsp/index.jsp/'
</PRE></div>

If you want any <TT>.asp</TT> file converted to <TT>.jsp</TT>, you
must match the file name with a regular expression and refer to it via
<TT>\1</TT>:

<div class="code"><PRE>
$ ... | sed 's/\(.*\).asp/\1.jsp/'
</PRE></div>

The <TT>\(...\)</TT> grouping collects text that you can refer to with
<TT>\1</TT>.

If you want to kill everything from the ',' character to end of line,
use the end-of-line marker <TT>$</TT>:

    :::shell-unix-generic
    $ ... | sed 's/,.*$//' # kill from comma to end of line


## Tarballs

Note: *The name comes from a similar word, **hairball** (stuff that
cats throw up), I'm pretty sure.*

To collect a bunch of files and directories together, use
<TT>tar</TT>.  For example, to tar up your entire home directory and
put the tarball into <TT>/tmp</TT>, do this

<div class="code"><PRE>
$ cd ~parrt
$ cd .. # go one dir above dir you want to tar
$ tar cvf /tmp/parrt.backup.tar parrt
</PRE></div>

By convention, use <TT>.tar</TT> as the extension.  To untar this file use

<div class="code"><PRE>
$ cd /tmp
$ tar xvf parrt.backup.tar

</PRE></div>

<TT>tar</TT> untars things in the <B>current</B> directory!

After running the untar, you will find a new directory,
<TT>/tmp/parrt</TT>, that is a copy of your home directory.  Note that
the way you tar things up dictates the directory structure when
untarred.  The fact that I mentioned <TT>parrt</TT> in the tar
creation means that I'll have that dir when untarred.  In contrast,
the following will also make a copy of my home directory, but without
having a <TT>parrt</TT> root dir:

<div class="code"><PRE>
$ cd ~parrt
$ tar cvf /tmp/parrt.backup.tar *
</PRE></div>

It is a good idea to tar things up with a root directory so that when
you untar you don't generate a million files in the current directly.
To see what's in a tarball, use

<div class="code"><PRE>
$ tar tvf /tmp/parrt.backup.tar
</PRE></div>

Most of the time you can save space by using the <TT>z</TT> argument.
The tarball will then be <TT>gzip</TT>'d and you should use file
extension <TT>.tar.gz</TT>:

<div class="code"><PRE>
$ cd ~parrt
$ cd .. # go one dir above dir you want to tar
$ tar cvfz /tmp/parrt.backup.tar.gz parrt
</PRE></div>

Unzipping requires the <TT>z</TT> argument also:

<div class="code"><PRE>
$ cd /tmp
$ tar xvfz parrt.backup.tar.gz
</PRE></div>

If you have a big file to compress, use <TT>gzip</TT>:

<div class="code"><PRE>
$ gzip bigfile
</PRE></div>

After execution, your file will have been renamed <TT>bigfile.gz</TT>.
To uncompress, use

<div class="code"><PRE>
$ gzip -d bigfile.gz
</PRE></div>

To display a text file that is currently <TT>gzip</TT>'d, use <TT>zcat</TT>:

<div class="code"><PRE>
$ zcat bigfile.gz
</PRE></div>


## Kopiowanie plików między komputerami

### rsync

When you need to have a directory on one machine mirrored on another
machine, use <TT>rsync</TT>.  It compares all the files in a directory
subtree and copies over any that have changed to the mirrored
directory on the other machine.  For example, here is how you could
"pull" all logs files from <TT>livebox.jguru.com</TT> to the box from
which you execute the <TT>rsync</TT> command:

<div class="code"><PRE>
$ hostname
jazz.jguru.com
$ rsync -rabz -e ssh -v 'parrt@livebox.jguru.com:/var/log/jguru/*' \
  /backup/web/logs
</PRE></div>

<TT>rsync</TT> will delete or truncate files to ensure the files stay
the same.  This is bad if you erase a file by mistake--it will wipe
out your backup file.  Add an argument called <TT>--suffix</TT> to
tell <TT>rsync</TT> to make a copy of any existing file before it
overwrites it:

<div class="code"><PRE>
$ hostname
jazz.jguru.com
$ rsync -rabz -e ssh -v --suffix .rsync_`date '+%Y%m%d'` \
 'parrt@livebox.jguru.com:/var/log/jguru/*' /backup/web/logs

</PRE></div>

where <TT>`date '+%Y%m%d'`</TT> (in reverse single quotes) means
"execute this <TT>date</TT> command".

To exclude certain patterns from the sync, use <TT>--exclude</TT>:

<div class="code"><PRE>
$ rsync -rabz --exclude=entitymanager/ --suffix .rsync_`date '+%Y%m%d'` \
  -e ssh -v 'parrt@livebox.jguru.com:/var/log/jguru/*' /backup/web/logs
</PRE></div>

### scp

To copy a file or directory manually, use <TT>scp</TT>:

<div class="code"><PRE>
$ scp lecture.html parrt@nexus.cs.usfca.edu:~parrt/lectures
</PRE></div>

Just like <TT>cp</TT>, use <TT>-r</TT> to copy a directory recursively.


## Pozostałe programy

### find

Most GUIs for Linux or PCs have a search facility, but from the
command-line you can use <TT>find</TT>.  To find all files named
<TT>.p4</TT> starting in directory <TT>~/antlr/depot/projects</TT>,
use:

<div class="code"><PRE>
$ find  ~/antlr/depot/projects -name '.p4'

</PRE></div>

The default "action" is to <TT>-print</TT>.

You can specify a regular expression to match.  For example, to look
under your home directory for any xml files, use:

<div class="code"><PRE>
$ find ~ -name '*.xml' -print
</PRE></div>

Note the use of the single quotes to prevent command-line
expansion--you want the '*' to go to the <TT>find</TT> command.

You can execute a command for every file or directory found that
matches a name.  For example, do delete all xml files, do this:

<div class="code"><PRE>
$ find ~ -name '*.xml' -exec rm {} \;
</PRE></div>

where "{}" stands for "current file that matches".  The end of the
command must be terminated with ';' but because of the command-line
expansion, you'll need to escape the ';'.

You can also specify time information in your query.  Here is a shell
script that uses <TT>find</TT> to delete all files older than 14 days.

<div class="code"><PRE>
#!/bin/sh

BACKUP_DIR=/var/data/backup

# number of days to keep backups
AGE=14 # days
AGE_MINS=$[ $AGE * 60 * 24 ]

# delete dirs/files
find $BACKUP_DIR/* -cmin +$AGE_MINS -type d -exec rm -rf {} \;
</PRE></div>


### fuser

If you want to know who is using a port such as HTTP (80), use
<TT>fuser</TT>.  You must be root to use this:

<div class="code"><PRE>
$ sudo /sbin/fuser -n tcp 80
80/tcp:              13476 13477 13478 13479 13480
13481 13482 13483 13484 13486 13487 13489 13490 13491
13492 13493 13495 13496 13497 13498 13499 13500 13501 13608
</PRE></div>

The output indicates the list of processes associated with that port.

### whereis

Sometimes you want to use a command but it's not in your <TT>PATH</TT>
and you can't remember where it is.  Use <TT>whereis</TT> to look in
standard unix locations for the command.

<div class="code"><PRE>
$ whereis fuser
fuser: /sbin/fuser /usr/man/man1/fuser.1 /usr/man/man1/fuser.1.gz
$ whereis ls   
ls: /bin/ls /usr/man/man1/ls.1 /usr/man/man1/ls.1.gz
</PRE></div>

<TT>whereis</TT> also shows <TT>man</TT> pages.

### which

Sometimes you might be executing the wrong version of a command and
you want to know which version of the command your <TT>PATH</TT>
indicates should be run. Use <TT>which</TT> to ask:

<div class="code"><PRE>
$ which ls
alias ls='ls --color=tty'
        /bin/ls
$ which java
/usr/local/java/bin/java
</PRE></div>

If nothing is found in your path, you'll see:

<div class="code"><PRE>
$ which fuser
/usr/bin/which: no fuser in (/usr/local/bin:/usr/X11R6/bin:/usr/X11R6/bin)
</PRE></div>

### kill, pkill

To send a signal to a process, use <TT>kill</TT>.  Typically you'll
want to just say <TT>kill pid</TT> where <TT>pid</TT> can be found
from <TT>ps</TT> or <TT>top</TT> (see below).

Use <TT>kill -9 pid</TT> when you can't get the process to die; this means kill it with "extreme prejudice".

### traceroute

If you are having trouble getting to a site, use <TT>traceroute</TT>
to watch the sequence of hops used to get to a site:

<div class="code"><PRE>
$ /usr/sbin/traceroute www.cnn.com
 1  65.219.20.145 (65.219.20.145)  2.348 ms  1.87 ms  1.814 ms
 2  loopback0.gw5.sfo4.alter.net (137.39.11.23)  3.667 ms  3.741 ms  3.695 ms
 3  160.atm3-0.xr1.sfo4.alter.net (152.63.51.190)  3.855 ms  3.825 ms  3.993 ms
...
</PRE></div>

### Jaki jest mój adres IP?

<div class="code"><PRE>
$ /sbin/ifconfig
</PRE></div>

Under the <TT>eth0</TT> interface, you'll see the <TT>inet addr</TT>:

<div class="code"><PRE>
eth0      Link encap:Ethernet  HWaddr 00:10:DC:58:B1:F0  
          inet addr:138.202.170.4  Bcast:138.202.170.255  Mask:255.255.255.0
          ...
</PRE></div>


## Użyteczne potoki: generowanie histogramu

**Uwaga**: zastąpić *awk* programem *cut*. Zamiast anlizować
plik *pageview-20021022.log* przeanalizować plik dziennika
railsów: zacząć od *grep 'Rendering '*

A histogram is set of count, value pairs indicating how often the
value occurs.  The basic operation will be to sort, then count how
many values occur in a row and then reverse sort so that the value
with the highest count is at the top of the report.

<div class="code"><PRE>
$ ... | sort |uniq -c|sort -r -n 
</PRE></div>

Note that <TT>sort</TT> sorts on the whole line, but the first column
is obviously significant just as the first letter in someone's last
name significantly positions their name in a sorted list.

<TT>uniq -c</TT> collapses all repeated sequences of values but prints
the number of occurrences in front of the value.  Recall the previous
sorting:

<div class="code"><PRE>
$ awk '{print $3;}' &lt; /home/public/cs601/unix/pageview-20021022.log | \
  sort | \
  uniq
/article/index.jsp
/article/index.jsp?page=1
/article/index.jsp?page=10
/article/index.jsp?page=2
...
</PRE></div>

<P>Now add <TT>-c</TT> to <TT>uniq</TT>:

<div class="code"><PRE>
$ awk '{print $3;}' &lt; /home/public/cs601/unix/pageview-20021022.log | \
  sort | \
  uniq -c
 623 /article/index.jsp
   6 /article/index.jsp?page=1
  10 /article/index.jsp?page=10
 109 /article/index.jsp?page=2
...
</PRE></div>

Now all you have to do is reverse sort the lines according to the first column numerically.

<div class="code"><PRE>
$ awk '{print $3;}' &lt; /home/public/cs601/unix/pageview-20021022.log | \
  sort | \
  uniq -c | \
  sort -r -n
6170 /index.jsp
2916 /search/results.jsp
1397 /faq/index.jsp
1018 /forums/index.jsp
 884 /faq/home.jsp?topic=Tomcat
...
</PRE></div>

In practice, you might want to get a histogram that has been
"despidered" and only has faq related views.  You can filter out all
page view lines associated with spider IPs and filter in only faq
lines:

<div class="code"><PRE>
$ grep -v -f /tmp/spider.IPs /home/public/cs601/unix/pageview-20021022.log | \
  awk '{print $3;}'| \
  grep '/faq' | \
  sort | \
  uniq -c | \
  sort -r -n
1397 /faq/index.jsp
 884 /faq/home.jsp?topic=Tomcat
 525 /faq/home.jsp?topic=Struts
 501 /faq/home.jsp?topic=JSP
 423 /faq/home.jsp?topic=EJB
...
</PRE></div>

If you want to only see despidered faq pages that were referenced more
than 500 times, add an <TT>awk</TT> command to the end.

<div class="code"><PRE>
$ grep -v -f /tmp/spider.IPs /home/public/cs601/unix/pageview-20021022.log | \
  awk '{print $3;}'| \
  grep '/faq' | \
  sort | \
  uniq -c | \
  sort -r -n | \
  awk '{if ($1&gt;500) print $0;}'
1397 /faq/index.jsp
 884 /faq/home.jsp?topic=Tomcat
 525 /faq/home.jsp?topic=Struts
 501 /faq/home.jsp?topic=JSP
</PRE></div>
