#### {% title "Git jest git" %}

# Git jest git

<blockquote>
  {%= image_tag "/images/jwz.gif", :alt => "[Jamie Zawinski]" %}
  <p>
   Zawinski's Law: Every program attempts to expand until it can read
   mail. Those programs which cannot so expand are replaced by ones
   which can.
  </p>
  <p class="author">— Jamie Zawinski</p>
</blockquote>

Do czego służy system *Git*? Odpowiedź znajdziemy na stronie domowej projektu
[Git - Fast Version Control System] [git home].

Obejrzenie wystąpienia autora Linuksa:
[Tech Talk: Linus Torvalds on git] [torvalds on git]
dla pracowników Google powinno wyjaśnić dlaczego powstał Git
i dlaczego Google więcej już nie poprosi LT o wygłoszenie referatu.

Randal L. Schwartz “Guru-On-Demand” jest autorem najlepszego
wprowadzenia do języka Perl jakie czytałem. Z jego
screencastu [Git] [schwartz on git] można dowiedzieć się 
jak Git zmienił jego życie.

Tom Preston-Werner w [Git Przypowieści] [the-git-parable] napisał:
„Most people try to teach Git by demonstrating a few dozen commands
and then yelling “tadaaaaa.” I believe this method is flawed. Such
a treatment may leave you with the ability to use Git to perform
simple tasks, but the Git commands will still feel like magical
incantations.”

Przypowieść ta opisuje perypetie czeladnika tworzącego system
gitopodobny od podstaw.

Różne: S. Chacon, [Git in One Hour] [git-in-one-hour].


## Konfiguracja

<blockquote>
 <p>
  Podchodzi informatyk do fortepianu i ogląda go wnikliwie: 
  — Hmm, tylko 84
  klawisze, z czego 1/3 funkcyjnych, wszystkie nieopisane,
  chociaż… shift naciskany nogą. Oryginalnie.
 </p>
</blockquote>

Pracę z gitem zaczynamy od przedstawienia się:

    git config -l
    git config --global user.name "Wlodek Bzyl"
    git config --global user.email "matwb@univ.gda.pl"
    
po czym natychmiast sprawdzamy, czy Git zrozumiał kim jesteśmy:

    cat ~/.gitconfig

Łatwiej będzie nam porozumiewać się z Gitem, po dodaniu do pliku
konfiguracyjnego kilku skrótów:

    git config --global alias.br branch -a
    git config --global alias.co checkout
    git config --global alias.ci commit
    git config --global alias.df diff
    git config --global alias.lg log -p
    git config --global alias.st status

Ułatwimy sobie śledzenie zmian w kodzie jeśli je podkolorujemy:

    git config --global color.branch auto
    git config --global color.diff auto
    git config --global color.status auto

Jeszcze trochę ręcznych robótek, bo czemu nie, w pliku konfiguracyjnym
i oto rezultat — mój plik *~/.gitconfig* w całej okazałości:

    :::ini
    [user]
      email = matwb@univ.gda.pl
      name = Wlodek Bzyl
    
    [color]
      branch = auto
      diff = auto
      status = auto
    
    [color]
      ui = true
    
    [core]
      whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
    
    [alias]
      br = branch -a
      co = checkout
      ci = commit
      df = diff
      lg = log -p
      st = status
    
i po konfiguracji.
    
Wygodnie też jest mieć kilka aliasów w bashu.
Dopisujemy je do pliku *~/.bashrc*:
    
    :::shell-unix-generic
    alias gb='git branch -a'
    alias gl='git log -p'
    alias gt='git status'


<blockquote>
 <h1>Zasłyszane</h1>
 <p>
  Q: Couldn't this be done using a Git repo?<br/>
  A: What's that “Git” thing?
  Diversion system is developed using “Mother Driven Development”. 
  With this system, you keep asking yourself:
  <em>Would my mother understand this?</em>
 </p>
 <p>
  Call it the poor man’s approach to usability.
 </p>
</blockquote>
    

## Podstawy

### Zakładamy repozytorium

Pierwsze repozytorium, zgodnie ze starą uniksową tradycją
powinno mieć nazwę *hello-world*:

    mkdir hello-world
    cd hello-world
    git init
    touch .gitignore README.md Makefile hello.c
    git add .
    git commit -m "pierwsza wrzutka"

Każdy plik w systemie Git może mieć aż trzy życia: jedno w „working tree”,
drugie w „index” i trzecie w „trunk”:

    git diff           # shows you the differences from index to working tree
    git diff HEAD      # shows you the differences from trunk to working tree
    git diff --cached  # shows you the differences from trunk to index

Na *indeks* mówimy też *staging*; *working tree* tłumaczymy 
*kopia robocza*; *trunk* to *trunk*.

Jak przetłumaczyć *staging area* — nie wiem;
*punkt etapowy*, *punkt tranzytowy* — niezbyt dobre.


### Git na codzień

Zazwyczaj praca z repozytorium wygląda tak:

    ... edycja, edycja ...
    git status
    git add [nazwy plików albo .]
    git commit -m "jakiś wpis do loga"
    ... edycja, edycja ...
    git status
    ... i tak w kółko ...


<blockquote>
 <p>
  Przychodzi administrator rano do pracy, siada do komputera, aby
  zobaczyć co się działo w nocy i śpiewa: <em>Chcę oglądać twoje logi,
  logi, logi, logi…</em>
 </p>
</blockquote>

### Przeglądanie logów i nie tylko

    git log
    git log -p

Użytecznymi programami są przeglądarki repozytoriów, na przykład

    gitk


### Undo różnych rzeczy

Zmieniamy **ostatni** wpis w logu: 

    git commit --amend    

Unstaging staged plik:

    git add .
    git status
    # On branch master
    # Changes to be committed:
    #   (use "git reset HEAD <file>..." to unstage)
    #
    #       modified:   README.md

Wycofanie zmian w edytowanym pliku:

    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #   (use "git checkout -- <file>..." to discard changes in working directory)
    #
    #       modified:   README.md


## Branching

*Pytanie*: Czym jest gałąź? (odgałęzienie?)

*Odpowiedź*: A branch in Git is simply a lightweight movable pointer
to one of these commits.

Gałęzie Gita najlepiej rozrysował S. Chacon w swojej książce:
[Pro Git] [progit branches]


### Tworzenie gałęzi w projekcie i ich scalanie

Przećwiczmy następujący scenariusz:

* Tworzymy serwis www z dowcipami.
* Tworzymy nową gałąź o nazwie *newidea* na nowy dowcip.
* Przenosimy się na gałąź *newidea*.
* Zaczynamy pisać nowy dowcip.

W trakcie pracy nad dowcipem dostajemy wiadomość, 
że kilka dowcipów na stronie nie jest śmiesznych. 
Przerywamy pracę nad nowym dowcipem i zabieramy się 
za odszukanie i poprawienie nieśmiesznych dowcipów.

<blockquote>
  {%= image_tag "/images/spowrotem.jpg", :alt => "[z powrotem]" %}
</blockquote>

* Wracamy na główną gałąź.
* Tworzymy nową gałąź o nazwie *hotfix*, 
  gdzie będziemy robić poprawki.
* Po przetestowaniu poprawek, 
  scalamy gałąź *hotfix* z gałęzią główną.
* Przenosimy się z powrotem na gałąź *newidea*
  gdzie kończymy pisać nowy dowcip.

A teraz konkrety. Serwis będzie dostępny z takiego URL:

    http://sigma.inf.ug.edu.pl/~wbzyl/dowcipy/

Na początek serwis www będzie się składał z jednej strony:
*index.html*.

Zakładamy repozytorium:

    mkdir ~/public_html/dowcipy/
    cd ~/public_html/dowcipy/
    cat > index.html
    

    


### Remote branches

Dodajemy oryginalny projekt jako *remote*.

Forkujemy projekt 

    http://github.com/technomancy/emacs-starter-kit

Klonujemy sforkowany projekt na swój komputer:

    git clone git@github.com:wbzyl/emacs-starter-kit.git

i dodajemy oryginalny projekt jako *remote*:

    git remote add technomancy git://github.com/technomancy/emacs-starter-kit.git

Teraz polecenie:

    git fetch technomancy

ściąga na gałąź *technomancy* najnowszą wersję oryginalnego projektu.

Teraz możemy porównać nową wersję ze swoja i scalić nową 
wersję ze swoim projektem.


### Prostowanie historii, czyli rebasing

Zobacz też [The Basic Rebase] (http://progit.org/book/ch3-6.html)

Zakładamy repo:

    mkdir test
    cd test
    cat > README.md
    # Hello project
    .. ctrl+d
    git init
    git add .
    git commit -m "wrzutka: 1."
    gitk

Nowy pomysł:

    git checkout -b newidea
    cat > README.md
    # Hello world project
    .. ctrl+d
    git commit -m "wrzutka z gałęzi newidea: 1." -a
    cat >> README.md
    Kolekcja programów hello world.
    .. ctrl+d
    git commit -m "wrzutka z gałęzi newidea: 2." -a
    gitk

Przechodzimy na główną gałąź:

    git checkout master
    cat >> README.md
    ## Ruby
        print "hello world"
    .. ctrl+d
    git commit -m "wrzutka: 2." -a
    gitk

Przechodzimy na newidea:

    git checkout newidea
    git rebase master     # rebase wykonujemy z gałęzi newidea
    git checkout master
    gitk

Wracamy na główną gałąź i usuwamy gałąź *newidea*:

    git merge newidea      # powinno być fast-forward
    gitk
    git branch -d newidea    
    gitk


## Praca rozproszona z *Githubem*

Przykład: wspólna praca nad moim projektem *jBlog*.

Wiesiek zakłada konto o nazwie *wp* na *github.com*
i dodaje klucz publiczny ze swojego komputera
do *SSH Public Keys* na swoim koncie *https://github.com/account*.

1. Teraz, po zalogowaniu się na konto, przechodzi na
   na stronę z moim projektem *http://github.com/wbzyl/jblog/*, 
   gdzie klika w ikonkę *fork* forkując w ten sposób **mój** projekt.
1. Po przejściu z powrotem na swoją stronę:
   *http://github.com/wp/* widzi, że projekt 
   *jblog* pojawił się na liście **jego** projektów.
1. Po kliknięciu na link z nazwą *jblog* zostaje przekierowany
   na stronę *http://github.com/wp/jblog*.
   Na tej stronie jest link **Your Clone URL**: *git@github.com:wp/jblog.git*.
1. Użwwając tego URL-a, Wiesiek klonuje sforkowane repozytorium na 
   swój komputer.

Teraz zaczyna robić się ciekawie.

1. Wiesiek dodaje nowy wpis do bloga. W katalogu 
   tworzy plik *2009-10-10-mercurial.markdown*,
   umieszcza go w repozytorium, wykonuje commit
   i push. 
1. Teraz ze strony projektu: *http://github.com/wp/jblog*
   klika w ikonkę *pull request*.

Ja po otrzymaniu *pull request*, dodaję sforkowane
repozytorium jako *remote*: `git add remote wp git://github.com/wp/jblog.git`.

1. Ściągam remote repo: `git fetch wp`.
1. Patrzę co zostało zrobione: `git diff wp/master`.
1. Scalam oba projekty: `git merge wp/master`.
1. Wykonuję commit i push.


## Zalety *nagich* repozytoriów

Jak utworzyć nagie repozytorium?
Załóżmy, że w katalogu *~/tmp/* mamy repozytorium *photos*.
Po wykonaniu polecenia:

    git clone --bare ~/tmp/photos ~/public_git/photos.git

Skąd takie określenie *nagi*. Wykonanie polecenia:

    ls ~/public_git/photos.git

powinno to wyjaśnić.

Zaletą jest możliwość pracy rozproszonej, takiej jak 
z repozytoriami githuba.


<blockquote>
 <p>
  Wsiada informatyk do taksówki. Taksiarz pyta:<br/>
  — Dokąd jedziemy?<br/>
  — 127.0.0.1
 </p>
</blockquote>


## Tak klonujemy projekty z *Sigmy*

Korzystając z protokołu GIT:

    git clone git://sigma.inf.ug.edu.pl/~wbzyl/test.git

Własne projekty klonujemy korzystając z SSH:

    git clone ssh://sigma.inf.ug.edu.pl/~wbzyl/public_git/test.git

albo tak:

    git clone wbzyl@sigma.inf.ug.edu.pl:public_git/test.git

To ostatnie polecenie nie mówi *explicite*, że ma być użyte ssh.



#### Linki

[git home]: http://git.or.cz "git home"
[the-git-parable]: http://tom.preston-werner.com/2009/05/19/the-git-parable.html "The Git Parable"
[torvalds on git]: http://www.youtube.com/watch?v=4XpnKHJAok8 "Tech Talk: Linus Torvalds on git"
[schwartz on git]: http://www.youtube.com/watch?v=8dhZ9BXQgc4 "Git"
[git-in-one-hour]: http://www.oreillynet.com/pub/e/1394 "Git in One Hour"
[progit branches]: http://progit.org/book/ch3-1.html "What a Branch Is"
